--
-- basic macros: implicit import
--

define* [bind
    macro* [a
        macro* [b
            code'|define* [{a b}]
        ]
    ]
]
bind [macro]
| macro* [{args}
    macro* [body
        code'|macro* [{args body}]
    ]
]
bind [if]
| macro [{condition}]
    | macro [{then}]
        | macro [{else}]
            | code'|if* [{condition} do[{then}] do[{else}]]
            
bind [of]
| macro [{args}]
    | macro [{body}]
        | macro [{alt}]
	       | code'|functions* [args-list[{args}] do[{body}] {alt}]
            
bind [match]
| macro [{args}]
	| macro [op]
		--| code'|{op}[{args}]
		| code'|invoke* [{op args}]
		
bind[async]
	| macro [method]
		| macro [{args}]
			code'|async*[method {args}]
			

--curious:
--bind [if]
--| of [=|true a _] [a]
--| of [=|false _ b] [b]
--!

--
-- basic functional operators: implicit import
--    
bind [fold-right]
| of [fn initial list[head {tail}]] [fn[head fold-right[fn initial tail]]]
| of [fn initial _] [initial] -- | of [fn initial list!] [initial]
!

--
-- buggy things
--
bind [num]
| macro [{args}]
	| if [is-defined|args|1][
        code'|{args|1}[number|{args|0} number|{args|2}]
    ]
    | code'|number|{args|0}

bind [set]
| macro [xa xop]
	| macro [xb]
		| code'|mutate*[{xa} {xop}[{xa xb}]] -- maybe here in op lies the problem -- permanent substitution
		
bind [<-]
| macro [aaa bbb]
    | code'|do[{bbb}]

bind [test]|number|2

-- seems that it makes xb be forever bound to if [false]...
-- maybe mutate* does something weird here?
set [test <-]
| if [false]
	[num|32]
| if [false]
	[number|33]
	[num[34 + 22]]
	       
--
-- tests
--

bind [fact]
| of [=|1] [1]
| of   [n] [* [n fact|- [n 1]]]
!

-- here be
fact[5]
-- dragons

bind [fib]
| of  [=|0] [0]
| of [<=|2] [1]
| of    [n] [+[fib|-[n 1] fib|-[n 2]]]
!

fib[3]

bind [x][5]

match [x]
| of  [=|0] [0]
| of [<=|2] [1]
| '[x greater than 2]


-- match [x] [fib] -- like postfix notation

-- functions*[of[] of[] of[]]

-- match [true]
-- | of [<[x 0]] ['[x is negative]]
-- | of      [_] ['[x is not negative]]
-- !

-- bind [t]
-- | if [>[a 0]] [a]
-- | if      [_] [0]
-- !

--
-- math
--
bind [square] -- perhaps make this native (js)/macro
| of [a] [
	*[a a]
]!

bind [sqrt] -- same
| of [a] [
	.[window Math sqrt][a]
]!

bind [sin]
| of [a] [
	.[window Math sin][a]
]!

bind [cos]
| of [a] [
	.[window Math cos][a]
]!

--
-- physics
--

bind [+vec]
| of [list[x1 y1] list[x2 y2]] [list[+[x1 x2] +[y1 y2]]]
!

bind [-vec]
| of [list[x1 y1] list[x2 y2]] [list[-[x1 x2] -[y1 y2]]]
!

bind [*vec]
| of [list[x1 y1] s] [list[*[x1 s] *[y1 s]]]
!

bind [line-circle-collision]
| of [line circle] [
	bind [d] [-vec[.[line 1] .[line 0]]]
	bind [f] [-vec[.[line 0] .[circle 0]]]
	
	bind [a] |+[square|.[d 0] square|.[d 1]]
	bind [b] |*[2 +[*[.[f 0] .[d 0]] *[.[f 1] .[d 1]]]]
	--bind [b] |*[2 +[
	--		*[.[f 0] .[d 0]] 
	--		*[.[f 1] .[d 1]]
	--]]
	-- bind [b] |*[2 +[*[f|0 d|0] *[f|1 d|1]]] -- perhaps this notation should be supported for lists
	bind [c] |-[+[square|.[f 0] square|.[f 1]] square|.[circle 1]]
	bind [delta] |-[square|b *[4 *[a c]]] -- *[4 a c]
	
	if [>=[delta 0]] [
		mutate* [delta .[window Math sqrt][delta]]
		
		bind [t1] |/[-[-#|b delta] *[2 a]]
		bind [t2] |/[+[-#|b delta] *[2 a]]
		
		or[and[>=[t1 0] <=[t1 1]] and[>=[t2 0] <=[t2 1]]]
	]
	| false
]!

bind [circle-circle-collision]
| of [circle-1 circle-2] [
	bind [v] |-vec[.[circle-1 0] .[circle-2 0]]
	bind [r] |+[.[circle-1 1] .[circle-2 1]]
	
	<[+[square|.[v 0] square|.[v 1]] square|r]
]!

bind [point-distance]
| of [p1 p2] [
	bind [diff] |-vec[p1 p2]
	.[window Math sqrt]|+[square|.[diff 0] square|.[diff 1]]
]!

--
-- output window
--
bind [iframe]|.[window document get-element-by-id]['|page]
bind [game-window]|.[iframe content-window]

bind [set-page]
| of [src] [
	:[iframe srcdoc src]
	-- modify [iframe] [srcdoc] [src]
	-- assign [iframe] [srcdoc] [src] -- assign means modify or extend
]!

--
-- game
--

-- game output
bind  [canvas-width] [600]
bind [canvas-height] [480]
bind  [container-id] |'[pillman-container]
bind      [canvas-A] |'[game-canvas-A]
bind      [canvas-B] |'[game-canvas-B]
		
set-page[html'[
<head>
	<style>
		body {
			background-color: #111;
			color: #ddd;
            transform: scale(0.5) translate(-70%, -50%);
		}

		a {
			color: #d99;
		}

		#info {
			font-size: 48px;
		}

		#container {
			width: 50%;
			margin: auto;
			text-align: center;
		}
		#{{container-id}} {
			position: relative;
			width: {{canvas-width}}px;
			height: {{canvas-height}}px;
			background-color: #010101;
			margin: auto;
		}

		#{{canvas-B}} {
			display: none;
			position: absolute;
			top: 0px;
			left: 0px;
		}

		#{{canvas-A}} {
			display: block;
			position: absolute;
			top: 0px;
			left: 0px;
		}

	</style>
</head>
<body>
	<div id="container">
		<h1>Pillman</h1>
		
		<div id="{{container-id}}" tabindex="1">
			<canvas id="{{canvas-A}}" width="{{canvas-width}}" height="{{canvas-height}}"></canvas>
			<canvas id="{{canvas-B}}" width="{{canvas-width}}" height="{{canvas-height}}"></canvas>
			<div id="info">Click this canvas to start.</div>
		</div>

		<div id="msg"></div>
		<span>The canvas above must be focused for the keyboard input to work.</span><br />
		<span>[SPACEBAR] controls Pillman</span><br />
		<span>or alternatively</span><br />
		<span>[Z] changes Pillman's direction and [X] changes Pillman's planet</span><br />
		<br />
		<span>[F2] restarts the game</span><br />
		<span>[F4] snapshots the canvas</span><br />
		<a id="download" tabindex="2" download=""></a>
	</div>
</body>
]]
			
-- .[lst 0]
-- lst[0]
-- lst|0
-- 0|lst
-- .[lst push]|5 -- could be colored specially
-- semantic coloring: when names don't mean values, should be different colors
-- bind [these are different][...]
-- lst['|push]|5


bind  [restart-key-code] [113]
bind [download-key-code] [115]
bind    [space-key-code] [32]
bind        [z-key-code] [90]
bind        [x-key-code] [88]

bind     [is-game-running] [false]
bind [is-time-for-restart] [true]
bind         [input-queue] [list!]
bind    [initial-fps-info] [list!]

-- simulation settings
bind [step][/[1 60]]
bind [double-buffer][true]

-- game state
bind [timeouts]
| dict* [
	eaten 120
	trapped 240
	vulnerable 720
	transition 60
	eat 10
	idle 120
	ate 60
]

-- temporary
bind [pillman-r][7]
bind [margin][8]

bind [pillman]
| dict*[
	idx 0
	position list[100 100]
	planet dict* [
		r 10
		x 100
		y 100
	]
	angle .[window Math PI]
	dir 1
	base-speed 0.02
	speed 0.02
	r pillman-r
	next-planet dict* [
		r 10
		x 100
		y 100
	]
	state '|normal
	timeout 0
	state-2 '|normal
	timeout-2 0
]

bind [get-initial-game-state]
| of![
	--bind [game-state][scope*!]
	--bind* [args-list[command] list|'|run game-state]
	
	--bind [game-state]
	--| 
	dict* [
		pillman pillman
		-- roger roger
		-- johnny johnny
		-- greg greg
		-- bill bill
		-- pills pills
		score 0
		pill-count 0
		lives 3
		level 1
		mode '|on
		timeout 0
		timeouts timeouts
		command '|run
	]
	
	--game-state
	
	-- :[game-state command '|run]
]!

-- bind [%]
-- | macro [a op b]
--	| code'{op}[{a b}]

-- macro -> on

bind [min]
| of [a b] [
	if [<[a  b]] [a]
	| b
]!
	
bind [handle-keys]
| of [input game-state] [
	--if [>[.[input length] 0]] [
		fold-right[handle-key game-state input]
	--]
	--| game-state
]!
	
bind [change-pillman-planet]
| of [game-state] [
	if [<>[.[game-state pillman next-planet] .[game-state pillman planet]]] [
		bind [new-planet]
		| match [.[game-state pillman next-planet]]
			| of [left-portal] [right-ghost-planet]
			| of [right-portal] [left-ghost-planet]
			| .[game-state pillman next-planet]
		--:[game-state pillman planet new-planet]
		--:[game-state pillman angle +[.[game-state pillman angle] .[window Math PI]]]
		--game-state
		
		inside* [.[game-state pillman] do[
			
			--put [new-planet +[.[game-state pillman angle] .[window Math PI]]]
			--| in [planet angle]
			--!
			
			mutate* [planet new-planet]
			mutate* [angle +[.[game-state pillman angle] .[window Math PI]]]
		]]
		
		--inside [game-state pillman]
		--| mutate [planet angle] [new-planet +[.[game-state pillman angle] .[window Math PI]]]
		
		--mutate-in [game-state pillman]
		--	[planet angle]
		--	[new-planet +[.[game-state pillman angle] .[window Math PI]]]
	]
	| game-state
]!
	
bind [handle-key]
| of [key game-state] [
	match [key]
	| of [list[=|restart-key-code =|'|down]] [mutate-in* [command '|restart game-state]]
	| of [list[=|download-key-code =|'|down]] [mutate-in* [command '|download game-state]]
	| if [=[.[game-state mode] '|on]] [
		match [key]
		| of [list[=|space-key-code =|'|down]] [
			mutate* [game-state change-pillman-planet[game-state]]
			--mutate-in* [dir -#|.[game-state pillman dir] .[game-state pillman]] 
			
			
			-- :[game-state change-pillman-planet[game-state]]
			-- this will set even if not defined:
			:[game-state pillman dir -#|.[game-state pillman dir]] -- negate[.[game-state pillman dir]]
		]
		| of [list[=|z-key-code =|'|down]] [
			:[game-state pillman dir -#|.[game-state pillman dir]] -- negate[.[game-state pillman dir]]
		]
		| of [list[=|x-key-code =|'|down]] [
			mutate* [game-state change-pillman-planet[game-state]]
		]
		| game-state
	]
	| game-state
	
	
]!

-- entity manipulation
bind [update-pillman]
| of [game-state] [
	bind [pillman] [.[game-state pillman]]
	bind [pillman-rr] [+[.[pillman planet r] +[pillman-r margin]]]
	
	
	assign* [.[game-state pillman]
		dict* [
			angle +[*[.[pillman dir] .[pillman speed]] .[pillman angle]]
			position list[
				+[*[pillman-rr sin[.[pillman angle]]] .[pillman planet x]] -- +*[pillman-rr sin[previous-angle] .[pillman planet x]]
				+[*[pillman-rr cos[.[pillman angle]]] .[pillman planet y]]
			]
			next-planet 0 -- temporary
		]
	]
	
	if [>[.[pillman timeout] 0]] [
		assign* [.[game-state pillman] dict* [timeout -[.[pillman timeout] 1]]]
	]
	| if [=[.[pillman state] '|normal]] [
		assign* [.[game-state pillman] dict* [state '|backward timeout .[game-state timeouts eat]]]
	]
	| if [=[.[pillman state] '|backward]] [
		assign* [.[game-state pillman] dict* [state '|normal timeout .[game-state timeouts eat]]]
	]
	!
	
	.[game-state pillman]
]!


bind [main-game-logic]
| of [game-state input] [
	assign* [game-state dict* [
		pillman update-pillman[game-state]
	]]

	game-state
]!

bind [update-logic]
| of [delta game-state input] [
	if [>[delta step]] [
		mutate* [game-state main-game-logic[game-state input]]
		
		update-logic[-[delta step] game-state list!]
	]
	| list[game-state delta]
]!


-- drawing aux
bind [clear]
| of [ctx] [
	:[ctx fillStyle '|#000]
	.[ctx fillRect][0 0 .[ctx canvas width] .[ctx canvas height]]
]!

-- bind [math] [.[window Math]]

bind [fill-circle]
| of [ctx x y r] [
	.[ctx beginPath]!
	.[ctx arc][x y r 0 *[2 .[window Math PI]] true]
	.[ctx fill]!
	.[ctx closePath]!
	-- ctx|arc[x y r 0 math|PI] -- todo: allow that again for one property (no quote needed)
]!

bind [swap-buffers]
| of [main-canvas disp-canvas] [
	bind [disp][.[game-window document getElementById][disp-canvas]]
	bind [main][.[game-window document getElementById][main-canvas]]
	bind [ctx][.[disp getContext]['|2d]]
	.[ctx drawImage][main 0 0]
	
	-- bind [condition] [=[.[main style display] '|block]]
	
	:[main style display '|block]
	:[disp style display '|none]
	
	clear[ctx]
]!

bind [xx][10]

bind [big-r][24]

--
--
-- drawing
--
-- 

--
-- colors
--
bind [pillman-color]['|#cc4]
bind [pupil-color]['|#111]
bind [eye-color]['|#ddd]
bind [text-color]['|#ddd]
bind [blink-color]['|#ddd]
bind [game-over-color]['|#c66]
bind [planet-color]['|#115]
bind [highlight-color]['|#282]

--
-- auxiliary drawing functions
--
bind [draw-lines]
| of [ctx x y off-a off-b] [
	.[ctx moveTo][+[x off-a] +[y off-a]]
	.[ctx lineTo][+[x off-b] +[y off-b]]
	.[ctx moveTo][+[x off-a] +[y off-a]]
	.[ctx lineTo][+[x off-b] +[y off-b]]
]!

bind [draw-pillman]
| of [ctx pillman game-state] [		
	match [.[game-state command]]
	| of [=|'|eaten-2] [ -- draw final frame of eaten animation
		bind [x] [.[pillman position 0]]
		bind [y] [.[pillman position 1]]
		
		:[ctx lineWidth 1]
		:[ctx strokeStyle pillman-color]
		.[ctx beginPath]!
		 
		.[ctx moveTo][x -[y 3]]
		.[ctx lineTo][x -[y 5]]
		.[ctx moveTo][x +[y 3]]
		.[ctx lineTo][x +[y 5]]
		.[ctx moveTo][-[x 3] y]
		.[ctx lineTo][-[x 5] y]
		.[ctx moveTo][+[x 3] y]
		.[ctx lineTo][+[x 5] y]
		
		.[ctx moveTo][-[x 2] -[y 2]]
		.[ctx lineTo][-[x 4] -[y 4]]
		.[ctx moveTo][+[x 2] +[y 2]]
		.[ctx lineTo][+[x 4] +[y 4]]
		.[ctx moveTo][-[x 2] +[y 2]]
		.[ctx lineTo][-[x 4] +[y 4]]
		.[ctx moveTo][+[x 2] -[y 2]]
		.[ctx lineTo][+[x 4] -[y 4]]
		
		.[ctx closePath]!
		.[ctx stroke]!
	]
	| do [ -- draw regular animation or animation for being eaten
  		bind* [
  			args-list[timeout total-timeout pi-fraction]
  			if [=[.[game-state command] '|eaten]] [
  				list[
  					.[game-state timeout]
  					+[1 .[game-state timeouts eaten]]
  					1
  				]
  			] [
  				list[
  					.[pillman timeout]
  					+[1 .[game-state timeouts eat]]
  					0.3
  				]
  			]
  		]
		
		-- bind* [name value] -- for simple values
		-- bind [...][...] -- for complex values
		
		-- of* [{args} body] -- simple
		-- of [] [] [] -- complex
		
		bind [angle]
		| if [=[.[pillman dir] 1]] [
			-[-#[.[pillman angle]] *[+[pi-fraction 0.1] .[window Math PI]]]
		] [
			+[-#[.[pillman angle]] *[-[1.1 pi-fraction] .[window Math PI]]]
		]
		
		bind [mouth-open]
		| match [.[pillman state]]
			| of [=|'|normal] [
				*[pi-fraction *[.[window Math PI] /[+[timeout 1] total-timeout]]]
			]
			| of [=|'|backward] [
				*[pi-fraction *[.[window Math PI] /[+[-[total-timeout timeout] 1] total-timeout]]]
			]
			| 0
			
	--	bind [mouth-open]
	--	| if [=[.[pillman state] '|normal]] [
	--		*[pi-fraction *[.[window Math PI] /[+[timeout 1] total-timeout]]]
	--	]
	--	| if [=[.[pillman state] '|backward]] [
	--		*[pi-fraction *[.[window Math PI] /[+[-[total-timeout timeout] 1]] total-timeout]]
	--	] [0]
		
			
		:[ctx fillStyle pillman-color]
		.[ctx beginPath]!
		
		.[ctx moveTo][.[pillman position 0] .[pillman position 1]]
		.[ctx arc] [
			.[pillman position 0]
			.[pillman position 1]
			pillman-r
			+[-[*[-[1 pi-fraction] .[window Math PI]] mouth-open] angle]
			+[mouth-open angle]
			false
		]
		.[ctx lineTo][.[pillman position 0] .[pillman position 1]]
		
		.[ctx closePath]!
		.[ctx fill]!
		
		-- draw the eye
		match [.[game-state command]]
		| of [=|'|eaten] []
		| of [=|'|eaten-2] []
		| do [
			bind [pillman-rr] [+[+[.[pillman planet r] .[pillman r]] margin]]
			bind [tail-length] [*[/[+[+[pillman-r margin] big-r] pillman-rr] 0.125]]
			bind [dir*length] [*[.[pillman dir] tail-length]]
			bind [angle-dir*length] [-[.[pillman angle] dir*length]]
			bind [rr+-2] [-[pillman-rr 2]]
			bind [x] [.[pillman planet x]]
			bind [y] [.[pillman planet y]]
			bind [rr+-2*sin] [*[rr+-2 sin|angle-dir*length]]
			bind [rr+-2*cos] [*[rr+-2 cos|angle-dir*length]]
			bind [rr+-2*sin+x] [+[rr+-2*sin x]]
			bind [rr+-2*cos+y] [+[rr+-2*cos y]]
			
			:[ctx fillStyle pupil-color]
			fill-circle[ctx rr+-2*sin+x rr+-2*cos+y 2]
			:[ctx fillStyle eye-color]
			fill-circle[ctx rr+-2*sin+x rr+-2*cos+y 1]
			0
		]
		0
	]
]!

--
-- main drawing function
--
bind [draw]
| of [game-state previous-time now fps-info] [
	bind[condition][or[=[.[.[game-window document getElementById][canvas-A] style display] '|none] not[double-buffer]]]

	bind [main-canvas][if[condition][canvas-A][canvas-B]]
	bind [disp-canvas][if[condition][canvas-B][canvas-A]]
	
	bind [ctx][.[.[game-window document getElementById][main-canvas] getContext]['|2d]]
	
	clear [ctx]
	
	--:[ctx fillStyle pillman-color]
	--:[ctx font '[50px monospace]]
	--.[ctx fillText]['[I am become Pillman] xx 60]
	
	--mutate*[xx if[>[xx 100]][10][+[xx 1]]]
	
	
	--:[pillman position 0 +[.[pillman position 0] 1]]
	draw-pillman[ctx pillman game-state]
	
	
	--.[.[.[game-window document getElementById][disp-canvas] getContext]['|2d] setFillColor][pillman-color]
	--.[.[.[game-window document getElementById][disp-canvas] getContext]['|2d] fillRect][0 0 100 100]
	
	
	-- double buffering
	if [double-buffer][swap-buffers[main-canvas disp-canvas]][]


	fps-info
]!

-- todo: implement missing pieces from here
-- implement bind-in, set-in macros based on new bind* primitive; add set* primitive
-- speed up parsing by removing all the debug stuff that gets displayed
-- fix the error on startup, when this file is loaded
bind [main-loop] -- this should be update-game
| of [game-state delta previous-time fps-info] [
	-- log|'[main loop executing]
	bind [input]|.[input-queue shift]! -- consider resetting input
	bind [now]|.[game-window Date now]!
	mutate* [delta +[delta min[1 /[-[now previous-time] 1000]]]]
	-- debug*!
	-- note: the next line causes bug with set
	-- set [delta <-]|+[delta min[1 /[-[now previous-time] 1000]]]
	-- #[delta + min[1 #[#[now - previous-time] / 1000]]]
	-- %[delta + min[1 %[%[now - previous-time] / 1000]]]
	-- (delta + min[1 ((now - previous-time) / 1000)])
	
	-- bind [list[new-game-state new-delta]]|update-logic[delta game-state input]
	bind [temp]|update-logic[delta game-state input]
	bind [new-game-state]|.[temp 0]
	bind [new-delta]|.[temp 1]
	
	if [=[.[new-game-state command] '|restart]] [
		-- log|'|restarting
		async*[.[game-window request-animation-frame] update-game]
	]
	| if [=[new-delta delta]] [ -- don't redraw if no logic updates
		-- log|'|no-redraw
		async*[
			.[game-window request-animation-frame]
			of![
				main-loop[new-game-state new-delta now fps-info]
			]!
		]
	]
	| async*[
		.[game-window request-animation-frame]
		of![
			main-loop[
				if [=[.[new-game-state command] '|download]] [
					-- set-in[new-game-state][command]['|run] -- returns updated new-game-state
					mutate-in* [command '|run new-game-state]
				]
				| new-game-state
				new-delta
				now
				draw[new-game-state previous-time now fps-info]
			]
		]!
	]
]!

bind [update-game] -- this should be (re)start-game
| of ![
	--
	-- call main-loop with initial game state
	-- 
	log|'[starting the game]
	async*[
		.[game-window request-animation-frame]
		of![
			main-loop[
				get-initial-game-state!
				0.0
				.[game-window Date now]!
				initial-fps-info
			]
		]!
	]
]!

bind [on-game-key-down]
| of [event] [
	.[input-queue push]|list[.[event key-code] '|down]
]!

bind [on-game-key-up]
| of [event] [
	.[input-queue push]|list[.[event key-code] '|up]
]!


bind [initialize-game]
| of [][
	if [=[false is-game-running]] [
		log|'[initializing the game]
		bind [game-container]|.[game-window document get-element-by-id][container-id]
		
		async*[.[game-container add-event-listener] '|keydown on-game-key-down]
		async*[.[game-container add-event-listener] '|keyup on-game-key-up]

		-- this should be mutate/set instead of bind
		bind*[args-list|display list|'[none] .[.[game-window document get-element-by-id]['|info] style]]
		
		mutate*[is-game-running true]
		
		-- note: should remove event listener instead of checking is-game-running,
		-- but in the current implementation it'll probably not work
		
		update-game!
	]
	| log|'[debug: game already initialized!]
]!

async*[.[window set-timeout] of![
	bind [c-a]|.[game-window document get-element-by-id][canvas-A]
	
	log|'|hello
	
	async*[.[c-a add-event-listener] '|focus initialize-game]
]! 1000]

-- of[event]|log[event] -- make this an error
-- of[event]|log[event]! -- this is ok, as it says that alternative is undefined
-- of[event]|log[event]|'[nope] -- this is ok, as it supplies a value alternative that will always work
